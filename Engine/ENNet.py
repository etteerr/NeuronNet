'''
Author: Erwin Diepgrond
Copyright 2016 under GNU license
e.j.diepgrond@gmail.com

	This file is part of NeuroNet.

	NeuroNet is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, 
	or any later version.

	NeuroNet is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with NeuroNet.  If not, see <http://www.gnu.org/licenses/>.
'''

import copy
from time import clock

from .Procpar import Pool
from .Procpar import Worker


class EnnWorker(Worker):
    def do(self,command):
        """
        Default class for various functions.
        You can overwrite this!
        :param command: commands in type 1, 2, 3 or 4
                        contains: [type,
        :return:
        """
        results = {}
        key = None
        if command[0]==3: #[[class,'member']] --> class.member() --> result --> [results]
            for i in command[1]:
                key = i[1]['id']
                results[key] = i[0](i[1])
        elif command[0]==4: #[[class,'member',(arguments)]] --> class.member() --> result --> [results]
            for i in command[1]:
                key = i[1][0]['id']
                results[key] = i[0](*i[1])
        else:
            return None #Unknown
        return results

class Simulator:
    """
    Simulator class:
        Simulates networks with neurons and synapses
        Networks are isolated. (may change but useful for simulating in parallel)
        fills recorders with data
        Gives a nice interface
    """
    def __init__(self, ignoreWarnings=False):
        """

        Initializes basic simulator class
        :param ignoreWarnings: Suppresses warnings when changing settings after a simulation has ran
        :return: self
        """
        self._ignoreWarnings = ignoreWarnings
        self._networks = {}
        self._networkIDCounter = 0 #Static maybe?
        self._recorderIDCounter = 0
        self._recorders = {}

    def addNetwork(self, network):
        """
        addNetwork adds a network to the simulation.
        Note that networks are independent simulations of their own
        :param network: a Network class network
        :return: network id generated by this class
        """
        #Create network
        network._id = self._networkIDCounter
        self._networks[self._networkIDCounter] = network
        self._networkIDCounter += 1
        return network._id

    def createNetwork(self, G, neuronClass, synapseClass, dt):
        """
        createNetworks call Network(neuronClass,synapseClass,dt,G) for you
        :param G: networkx network
        :param neuronClass: neuron class derived from the BaseNeuron class in Neurons.py
        :param synapseClass: synapse class derived from the baseSynapse class in Synapses.py
        :param dt: the simulation time step in ms
        :return: network id generated by this class
        """
        network = Network(neuronFun=neuronClass, synapseFun=synapseClass, dt=dt, networkx=G)
        return self.addNetwork(network)

    def getNetwork(self, networkId):
        """

        :param networkId: Hashable object specifying networkId
        :return: reference to Network class corresponding to networkId
        """
        try:
            return self._networks[networkId]
        except:
            print('getNetwork: Unknown network')
            return None

    def addRecorder(self, recorder):
        """

        :param recorder: recorder to add to the simulation
        :return: Hashable object specifying recorder ID
        """
        id = self._recorderIDCounter
        self._recorderIDCounter += 1
        recorder.id = id
        self._recorders[id] = recorder
        return id

    def getRecorder(self, recorderId):
        """

        :param recorderId:  Hashable object specifying recorder ID
        :return: Recorder class recorder corresponding to recorderId
        """
        try:
            return self._recorders[recorderId]
        except:
            print('getRecorder: Unknown recorder')
            return None

    def simulate(self, duration_ms, network=None, poolSize=None):
        """
        Starts the simulation for specified duration for all networks
        :param duration_ms: Duration of simulation in ms
        :param network: Specify a networkid to simulate
        :return: None
        """
        print('Starting a %fms network simulation..' % duration_ms)
        if network==None:
            for (_,i) in self._networks.items():
                i.simulate(duration_ms, self._recorders, poolSize=poolSize)
        elif network in self._networks.keys():
            self._networks[network].simulate(duration_ms, self._recorders, poolSize=poolSize)


class Network:
    _suppressChangeWarnings = False

    def __init__(self, neuronFun, neuronDict, synapseFun, synapseDict, dt, networkx=None, verbose=False):
        """
        Generates a network based on the parameters
        :param neuronFun: neuron class derived from the BaseNeuron class in Neurons.py (initialized)
        :param sypanse: synapse class derived from the baseSynapse class in Synapses.py (initialized)
        :param dt: the simulation time step in ms
        :param networkx: a network from the networkx package. If None, initializes empty network
        """
        self._id = None
        self._dt = dt
        self._verbose = verbose
        self._neurons = {}
        self._synapses = {}
        self._neuronCounter = 0
        self._synapseCounter = 0
        self._synapseFun = synapseFun #
        self._neuronFun = neuronFun
        self._neuronDict = neuronDict
        self._synapseDict = synapseDict
        self._pool = None
        self._time = 0
        self._timeline = []
        self._recorders = []
        if not networkx == None:
            print('Creating network with %i nodes and %i connections...'%(networkx.number_of_nodes(),networkx.number_of_edges()))
            start = clock()
            for (i,data) in networkx.nodes_iter(data=True):
                n = copy.copy(neuronDict)
                n.update(data)
                self.addNeuron(n,i)

            for (i,j,data) in networkx.edges_iter(data=True):
                self.connect(i, j, data,synapseFun, synapseDict)
            print('done! (%.2f seconds)'%(clock()-start))

    def addNeuron(self, neuronDict=None, id=None, neuronFun=None):
        """
        adds a neuron
        :param neuronFun: neuron class derived from the BaseNeuron class in Neurons.py
        :return: returns the ID of the generated neuron
        """
        if id == None: #if none: Choose new Unused ID
            id = self._neuronCounter
            while id in self._neurons.keys():
                self._neuronCounter += 1
                id = self._neuronCounter
        elif id in self._neurons.keys(): # If specified but exists, Error time :D
            raise IndexError('Index already exists!')

        if neuronFun==None:
            neuronFun = self._neuronFun

        if neuronDict==None:
            neuronDict = self._neuronDict

        #Add neuron
        neuronDict = copy.deepcopy(neuronDict)
        neuronDict['fun'] = neuronFun
        neuronDict['id'] = id
        neuronDict['dt'] = self._dt
        self._neurons[id] = neuronDict
        return id

    def connect(self, sourceId, destinationId,settingsDict={},synapseFun=None,synapseDict=None):
        """
        connects two neurons  (sourceId -> destinationId)
        :param sourceId: the source neuron
        :param settingsDict: a dictionary specifying attributes of the neuron.
                             These will override existing variables
        :param destinationId: the destination neuron
        :return: Synapse ID
        """
        id = self._synapseCounter
        if synapseDict==None:
            synapseDict = self._synapseDict

        if synapseFun == None:
            synapseFun = self._synapseFun

        synapseDict = copy.deepcopy(synapseDict)
        synapseDict.update(settingsDict)
        synapseDict['_source'] = sourceId
        synapseDict['_destin'] = destinationId
        synapseDict['id'] = id
        synapseDict['fun'] = synapseFun
        self._synapseCounter += 1
        self._synapses[id] = synapseDict
        return id

    def deleteConnection(self,id):
        """
        Deletes specified connection.
        :param id: Key specifying synapse
        :return: connection class (if you want it)
        """
        return self._synapses.pop(id)

    def deleteNeuron(self, id):
        """
        deletes neuron with id: id
        This id will not return, its a gap in the IDs. Keep this in mind when using recorders
        :param id: id of neuron to delete
        :return: returns the neuron class that is deleted
        """
        ids = []
        #find connections TODO: Create a function find to find neurons or connections based on dict
        for (_id, synapse) in self._synapses.items():
            if synapse['_source'] == id or synapse['_destin'] == id:
                ids.append(_id)
        #Delete synapses
        for _id in ids:
            self.deleteConnection(_id)


        return self._neurons.pop(id)

    def getNeuronIDs(self):
        """
        :return: a list containing all IDs of (not deleted) neurons
        """
        return self._neurons.keys()

    def getConnectionIDs(self):
        """
        :return: a list containing all IDs of (not deleted) synapses (connections
        """
        return self._synapses.keys()

    def getNeuronByID(self,id):
        return self._neurons[id]

    def _drange(self,start,stop,step=1):
        i = start
        while i < stop:
            yield i
            i += step

    def drange(self,start,stop,step=1):
        line = []
        i = start
        while i < stop:
            line.append(i)
            i += step
        return line

    def simulate(self, duration, recorders, poolSize=None):
        """
        Simulates one neuron for time (ms)
        :param duration: duration of simulation in ms
        :param recorders: The recorders for this network
        :param poolSize: The amount of subprocess. < 1 or None = Local only
        :return: I wont return a value or anything... baka
        """
        #Generate timeline
        timeline = self.drange(self._time+self._dt,self._time + duration, self._dt)

        #Set recorders
        self._recorders = []
        for (_,recorder) in recorders.items():
            if recorder._networkId==self._id:
                recorder.timeline+=timeline
                self._recorders.append(recorder)

        # Add to current timeline
        self._timeline +=timeline

        # Start simulation
        if poolSize is None:
            self.localSim(timeline=timeline)
        elif poolSize > 0:
            self.poolSim(timeline=timeline, poolSize=poolSize)
        else:
            print(
                'Invalid poolSize %i. Only values bigger than 0 will result in a pooled simulation.\nStarting local simulation...' % poolSize)
            self.localSim(timeline=timeline)

        return 'Baka!'

    ##################################### Pooled Operations #####################################
    def poolSim(self, timeline, poolSize):
        del self._pool
        self._pool = Pool(poolSize, verbose=self._verbose, workerClass=EnnWorker)

        etaEvery = 10#seconds (no more than 1 in 5 seconds)
        sPassed = 0
        stepCounter = 0
        totalSteps = len(timeline)

        startTime = clock()
        #loop
        for time in timeline:
            stepTime = clock()
            self._time = time
            self._poolStep()
            stepCounter+=1
            stepTime=clock()-stepTime
            sPassed+=stepTime
            if sPassed > etaEvery:
                stepsRemaining = totalSteps-stepCounter
                runtime = clock()-startTime
                print('Estimated time remaining: %.4f seconds  (running %.2f seconds)' %((runtime/stepCounter)*stepsRemaining,runtime))
                sPassed = 0

        self._pool.close()

    def _poolStep(self):
        if self._verbose: t=clock()
        self._poolUpdateNeurons()
        self._poolUpdateSynapses_yielding()
        self._updateRecorders()
        if self._verbose:
            print('Total update time: %.5f' % (clock()-t))
            print('-------------------------')

    def _poolUpdateNeurons(self):
        if self._verbose: t=clock()
        self._pool.dispatchJobType3([[i['fun'],i] for (_,i) in self._neurons.items()])
        self._neurons = self._pool.getResult(dict=True)
        if self._verbose: print('update neurons total: %.5f' % (clock()-t))

    def _poolUpdateSynapses(self):
        if self._verbose: t = clock()
        self._pool.dispatchJobType4([[i['fun'],(i,self._neurons[i['_source']],self._neurons[i['_destin']])] for (_,i) in self._synapses.items()])
        if self._verbose: print('Synapse Dispatch: %.5f' % (clock()-t))
        if self._verbose: t = clock()
        res = self._pool.getResult(dict=True)
        if self._verbose: print('Synapse Get: %.5f' % (clock()-t))
        if self._verbose: t = clock()
        for (_,[synapse,_,dest]) in res.items():
            self._synapses[synapse['id']]  = synapse
            self._neurons[dest['id']]['I'] += dest['I'] #TODO: Other values are not updated, maybe do something?
        if self._verbose: print('Synapse Set: %.5f' % (clock()-t))

    def _poolUpdateSynapses_yielding(self):
        if self._verbose: t = clock()
        self._pool.dispatchJobType4([[i['fun'],(i,self._neurons[i['_source']],self._neurons[i['_destin']])] for (_,i) in self._synapses.items()])
        if self._verbose: print('Synapse Dispatch: %.5f' % (clock()-t))
        if self._verbose: t = clock()
        for data in self._pool.getResultsYielding():
            for (_,[synapse,_,dest]) in data.items():
                self._synapses[synapse['id']]  = synapse
                self._neurons[dest['id']]['I'] += dest['I'] #TODO: Other values are not updated, maybe do something?
        if self._verbose: print('Synapse Set: %.5f' % (clock()-t))

    ##################################### Local operations #####################################
    def localSim(self, timeline):
        etaEvery = 10  # seconds (no more than 1 in 5 seconds)
        sPassed = 0
        stepCounter = 0
        totalSteps = len(timeline)

        startTime = clock()
        # loop
        for time in timeline:
            stepTime = clock()
            self._time = time
            self._localStep()
            stepCounter += 1
            stepTime = clock() - stepTime
            sPassed += stepTime
            if sPassed > etaEvery:
                stepsRemaining = totalSteps - stepCounter
                runtime = clock() - startTime
                print('Estimated time remaining: %.4f seconds  (running %.2f seconds)' % (
                    (runtime / stepCounter) * stepsRemaining, runtime))
                sPassed = 0

    def _localStep(self):
        if self._verbose: t = clock()
        self._localUpdateNeurons()
        self._localUpdateSynapses()
        self._updateRecorders()
        if self._verbose:
            print('Total update time: %.5f' % (clock() - t))
            print('-------------------------')

    def _localUpdateNeurons(self):
        if self._verbose: t = clock()
        for (key, neuron) in self._neurons.items():
            self._neuronFun(neuron)
        if self._verbose: print('update neurons total: %.5f' % (clock() - t))

    def _localUpdateSynapses(self):
        if self._verbose: t = clock()
        for (key, synapse) in self._synapses.items():
            synapse, self._neurons[synapse['_source']], self._neurons[synapse['_source']] = \
                self._synapseFun(synapse, self._neurons[synapse['_source']], self._neurons[synapse['_source']])
        if self._verbose: print('update synapses total: %.5f' % (clock() - t))

    def _updateRecorders(self):
        if self._verbose: t=clock()
        for recorder in self._recorders:
            for nid in recorder._neuronIds:
                for var in recorder._variables:
                    recorder[var][nid].append(self._neurons[nid][var])
        if self._verbose: print('Recorder updates: %.5f' % (clock()-t))


class Recorder(object):
    def __init__(self, networkId, neuronIds, variables=['Vm'], withTime=False):  # TODO: WithTime
        self._networkId = networkId
        self._neuronIds = neuronIds
        self._variables = variables
        self.timeline = []

        for var in variables:
            self[var] = {}
            for i in neuronIds:
                self[var][i] = []

    def __getitem__(self, item):
        return getattr(self,item)

    def __setitem__(self, key, value):
        setattr(self,key,value)

def dumpclean(obj):
    if type(obj) == dict:
        for k, v in obj.items():
            if hasattr(v, '__iter__'):
                print( k)
                dumpclean(v)
            else:
                print('%s : %s' % (k, v))
    elif type(obj) == list:
        for v in obj:
            if hasattr(v, '__iter__'):
                dumpclean(v)
            else:
                print (v)
    else:
        print (obj)




